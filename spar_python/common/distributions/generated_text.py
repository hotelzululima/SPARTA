# *****************************************************************
#  Copyright 2013 MIT Lincoln Laboratory  
#  Project:            SPAR
#  Authors:            jch
#  Description:        A class for the text generated by text_generator.py
#                      and text_distribution.py
# 
#  Modifications:
#  Date          Name           Modification
#  ----          ----           ------------
#  1 Oct 2013    jch           Original file
# *****************************************************************


import spar_python.common.spar_stemming as spar_stemming
import spar_python.common.spar_random as spar_random

class GeneratedText(object):

    """
    This class holds the text generated by the TextGenerator and 
    TextDistribution classes. If speed were not a problem, these two classes
    would just return strings. However, we will need to do intellegent 
    searching/matching/processing against the generated text, and this
    processing is a bottleneck. Thus, it makes sense to store this generated
    text in a more structured way and to provide useful/optimized methods over
    it.
    
    Currently, objects of this class hold three lists:
    * A list of words (case sensitive; spaces/punctuation considered to be 
    individual words),
    * A list of word-stems, and
    * A list of upper-case strings.
    
    These three lists are guaranteed to be the same length, and it is 
    guaranteed that for all i,
    
    * stem_list[i] is the stem of word_list[i], and
    * upper_case_list[i] is word_list[i].upper()
    
    If word_list[i] is not a word, then stem_list[i] is None.
    
    Also, this class exports two attributes indicating the presence or 
    absence of alarmwords:
    
    * self.alarmwords will be a list of alarmwords present in this text. 
    (It could be empty.)
    
    * self.alarmword_distances will be either None or a list of distances
    between alarmwords in this text. For example:
    
      self.alarmwords         self.alarmword_distances
      ---------------         ------------------------
      
      []                      None
      [w1]                    None
      [w1, w2]                [distance_from_w1_to_w2]
      [w1, w2, w3]            [distance_from_w1_to_w2, distance_from_w2_to_w3]

    Etc.
    
    """

    def __init__(self, word_list, stem_list, upper_word_list):

        # Do this hear to avoid circular imports
        from spar_python.common.distributions.text_generator import TextGenerator

        assert len(word_list) == len(upper_word_list)
        assert len(word_list) == len(stem_list)
        assert None not in word_list, (word_list, upper_word_list)
        assert None not in upper_word_list, (word_list, upper_word_list)      

        self.word_list = word_list
        self.stem_list = stem_list
        self.upper_word_list = upper_word_list
        
        # These will be given values by methods so that they only need
        # to be computed once
        self._cased_string = None
        self._upper_string = None
        self._word_set = None
        self._stem_set = None
        self._upper_set = None
                
        # A useful set for filtering out non-words
        self._non_words = frozenset(TextGenerator.START_TOKENS | set([' ']))

        # Attributes to signal information about the presence/absence of
        # alarmwords
        self.alarmwords = []
        self.alarmword_distances = None

        # For the moment, cannot add alarmwords to this object more than once.
        self._alarmwords_added = False

    def _reset_helpers(self):        
        # re-set all pre-computed auxilary information
        self._cased_string = None
        self._upper_string = None
        self._word_set = None
        self._stem_set = None
        self._upper_set = None


        
    def __len__(self):
        return len(self.str())
    
    def __str__(self):
        return self.str()
    
    def str(self):
        if not self._cased_string:
            self._cased_string = "".join(self.word_list)
        return self._cased_string


    def _is_real_word(self, token):
        """
        Returns True unless the token is recognized as a non-word
        thing, like None or '.'.
        """
        return not (token in self._non_words)


    @property
    def word_set(self):
        if not self._word_set:
            real_words = filter(self._is_real_word, self.word_list)
            self._word_set = frozenset(real_words)
        return self._word_set

    @property
    def upper_set(self):
        if not self._upper_set:
            real_uppers = filter(self._is_real_word, self.upper_word_list)
            self._upper_set = frozenset(real_uppers)
        return self._upper_set


    @property
    def stem_set(self):
        if not self._stem_set:
            real_stems = filter(lambda s: s is not None, self.stem_list)
            self._stem_set = frozenset(real_stems)
        return self._stem_set


    
    def upper(self):
        """
        Equal to `self.str().upper()`, but faster.
        """
        if not self._upper_string:
            self._upper_string = "".join(self.upper_word_list)
        return self._upper_string


    def contains_word(self, token):
        return token in self.word_set

    def contains_stem(self, stem):
        return stem in self.stem_set
    
    def contains_upper(self, token):
        return token in self.upper_set
    
    
    def add_single_alarmword(self, alarmword):
        """
        Adds a single word to a random location in the text.
        Note: adds space both before and after, even if this makes a 
        double-space or a space between a word and punctuation. Used for
        adding alarmwords to text.
        """
        
        assert not self._alarmwords_added, "Cannot add alarmwords more than once"
        
        # add the new word and stem to internal lists
        word_upper = alarmword.upper()
        stem = spar_stemming.stem_word(word_upper)
        
        end_first_trigram = 6
        begin_last_trigram = len(self.word_list) - 6
        insert_point = spar_random.randint( end_first_trigram, 
                                            begin_last_trigram )
        
        # Note: why do we force the insert of leading and following spaces?
        # We *could* try to do something smarter, and only insert one space 
        # to keep the spacing as in natural englilsh. But we (Jon) are not
        # smart enough to get this right, and the consqeuence of getting
        # this wrogn may be inadvertantly putting two words together with no
        # space in between. This will lead to an extremely subtle bug where
        # the aggregators and the databases disagree about what words are
        # in a asentence. Putting in extra spaces, on the other hand, shouldn't
        # break anything (and is even to be expected in real human-generated
        # text.
        
        # Note: the order of the next loop is fragile:
        for (word, stem, upper) in [(' ', None, ' '),
                                    (alarmword, stem, word_upper),
                                    (' ', None, ' ')]:
            self.word_list.insert(insert_point, word)
            self.stem_list.insert(insert_point, stem,)
            self.upper_word_list.insert(insert_point, upper)
                
        self._reset_helpers()
        self._alarmwords_added = True
        self.alarmwords = [alarmword]
        self.alarmword_distances = None

    def add_two_alarmwords(self, first_word, second_word, max_distance):
        """
        Adds the two words to the generated text, in the given order, such
        that the number of characters between them (but not including either)
        is less than max_distance. Will also ensure that the distance is not 
        'too much' less than max_distance, where 'too much' is a tunable
        parameter. Raises AssertionError if the text is not long enough
        to make the addition possible. 
        """
        
        # Okay, here's how this works. Until we find a good solution, we
        # repeatedly try the following:
        #
        # Choose a random location in the list after the first five elements
        # (so as to not trample on the first trigram).
        # 
        # Now, walk forward from that location, counting characters, until we
        # would either exceed the max_distance or enter the last trigram
        # 
        # test: is the best-found distance tolerable, meaning within an
        # acceptable margin?  If so, insert. Else, start again from scratch.

        # NOTE!!!: Spaces must always be inserted before and after the alarm words 
        # in order for the base line to properly parse alarm words. 
        
        assert not self._alarmwords_added, "Cannot add alarmwords more than once"
        
        acceptable_margin = 10
        
        assert len(str(self)) > max_distance - acceptable_margin
        
        solution_found = False
        
        list_len = len(self.word_list)
        end_first_trigram = 6
        begin_final_trigram = list_len - 6 # To include spaces and punctuation
        while not solution_found:
            # will be between 0 (inclusive) and list_len (exclusive)
            first_insert_point = spar_random.randint( end_first_trigram, 
                                                      begin_final_trigram )
            second_insert_point = first_insert_point 
            
            current_distance = 2 # to account for the two intermediate 
                                 # spaces we will insert
            next_word = self.word_list[second_insert_point]
            next_distance = current_distance + len(next_word)
            while all([next_distance <= max_distance,
                       second_insert_point + 1 <= begin_final_trigram]):                
                second_insert_point += 1
                current_distance = next_distance
                next_word = self.word_list[second_insert_point]
                next_distance += len(next_word)

            
            
            margin = max_distance - current_distance
            if margin <= acceptable_margin:
                solution_found = True
            
        # Found a solution. Note: the order in the next loop is FRAGILE. 
        # Do not re-order without working it through!
        for (word, insert_point) in [(second_word, second_insert_point),
                                     (first_word, first_insert_point)]:


            word_upper = word.upper()            
            stem = spar_stemming.stem_word(word_upper)


            # Note: why do we force the insert of leading and following spaces?
            # We *chould* try to do something smarter, and only insert one space
            # to keep the spacing as in natural englilsh. But we (Jon) are not
            # smart enough to get this right, and the consqeuence of getting
            # this wrogn may be inadvertantly putting two words together with no
            # space in between. This will lead to an extremely subtle bug where
            # the aggregators and the databases disagree about what words are in
            # a asentence. Putting in extra spaces, on the other hand, shouldn't
            # break anything (and is even to be expected in real human-generated
            # text.

            
            for (word_entry, stem_entry, upper_entry) in [(' ', None, ' '),
                                                          (word, stem, 
                                                           word_upper),
                                                          (' ', None, ' ')]:

                self.word_list.insert(insert_point, word_entry)
                self.stem_list.insert(insert_point, stem_entry)
                self.upper_word_list.insert(insert_point, upper_entry)

        self._reset_helpers()
        self._alarmwords_added = True
        self.alarmwords = [first_word, second_word]
        self.alarmword_distances = [current_distance]
        
        