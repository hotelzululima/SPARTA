# *****************************************************************
#  Copyright 2013 MIT Lincoln Laboratory  
#  Project:            SPAR
#  Authors:            JCH
#  Description:        Classes related to artifical XML-generation
#  Modifications:
#  Date          Name           Modification
#  ----          ----           ------------
#  3 Oct 2013  jch            Original Version
#  17 Oct 2013 jch            Changed generate() from recursive to stack-based
# *****************************************************************


"""
This module holds a number of related classes useful for generating random
artifical XML for the SPAR project:

* The GeneratedXml class holds the random artifical XML. Aggregators will 
  be processing objects from this class, and so this method exposes a number
  of useful methods to make these aggregators simple. This class also supports
  `__str__()`, and so the built-in function str() can turn objects of this
  class into the XML string. It also, however, supports a few methods for
  testing the object:
  
  * matches_query() takes in any XPath expression (but supports only a subset of
  the XPath language for direct searching against the XML. See the documentation
  for xml.etree.ElementTree for more information on the subset of XPath
  supported.
  
  * has_leaf() and has_path() are more specialized and optimized tests for
  the kinds of queries we know we will want to make in Phase 2.
  
* The XmlGenerator class is the class actually created by the 
  distribution-learner and used in DataGenerationEngine to create random 
  instances of GeneratedXml. This class is actually fairly generic and 
  parameterized by other classes (below) so that we can more-easily change our
  algorithm/distribution for the generated XML.
  
* The actual generation of random XML is performed by instances of the 
  LeafGenerator and BranchGenerator classes. In general, these classes will
  take in the XML path so far and return either a leaf node or a list of 
  interior nodes, respectively. Right now, the implementations of these classes
  are very simple and do not actually use all the flexbility allowed to them.
  That is becuase our current XML distribution is very simple-- but may change
  in the future.
  
  Two additional notes about these classes:
  
  1) The LeafGenerator class is paramaterized by a DistributionHolder object,
     which must be provided to the XmlGenerator's constructor.
     
  2) The XmlGenerator class repeatedly these LeafGenerator and BranchGenerator
     classes to generate the full XML tree. To communicate nodes back to
     the XmlGenerator class, the *Generator classes will use a named-tuple
     class called NodeSpec.

"""


import os
import sys
this_dir = os.path.dirname(os.path.abspath(__file__))
base_dir = os.path.join(this_dir, '..', '..')
sys.path.append(base_dir)

import xml.etree.cElementTree as ElementTree
import collections


from spar_python.common.distributions.base_distributions import CompactIndependentDistribution
import spar_python.common.spar_random as spar_random
import spar_python.data_generation.spar_variables as spar_vars

def weight_vector(i):
    weights = [1,5,10]
    exp = int(i / 3)
    return weights[i%3]*10**exp

XML_DEPTH = 3
FAN_OUT = 5

class GeneratedXml(object):
    """
    Class to hold arificial XML generated by the XmlGenerator class. Note that
    this class (GeneratedXml) is mostly a thin wrapper around an ElementTree
    (see xml.etree.ElementTree) passed in to the constructor. Indeed, some
    methods of this class (e.g., matches_xpath_expression()) are passed through
    to the underlying ElementTree. However, two methods (has_leaf() and
    has_path()) are bottlenecks and hence are heavily optimized. 

    """
    
    def __init__(self, etree):
        self._etree = etree

        # The following hold data derived from the etree, so as to memoize
        # work and optimize the query-aggregation
        self._str_form = None
        
        # will hold (tag, value) pairs for all leaves
        self._leaves = self._precompute_leaves(etree) 
        
        # will hold (tag1, tag2, ... leaf-tag, leaf-value tuples for all paths
        self._paths = self._precompute_paths(etree)
                         
                         
    def _precompute_leaves(self, etree):
        """
        Returns a set of all (leaf-tag, leaf-value) pairs in the tree.
        Note: leaf-value is None when the leaf does not have a text attribute.
        This function is used internally for optimization pre-computation.
        """
        return_me = set()
        for node in etree.iter():
            children = list(node)
            if not children:
                tag = node.tag
                try:
                    val = node.text.upper()
                except AttributeError:
                    val = node.text
                new_tuple = (tag, val)
                return_me.add(new_tuple)
        return return_me
    
    def _precompute_paths(self, etree):
        """
        Returns a set of tuples, each of the form
        
          (tag1, tag2, tag3,... leaf_tag, leaf_value)
          
        for all paths in the tree. Note: leaf-value is None when the leaf does
        not have a text attribute. This function is used internally for
        optimization pre-computation.
        """
        return_me = set()
        root = etree.getroot()
        
        # Will do a depth-first-search for leaves via a stack holding
        # (node, path-to-node-parent) pairs        
        
        first_tuple = (root, [])
        stack = [first_tuple]
        
        while stack:
            (node, path) = stack.pop()
            
            children = list(node)
            
            if children:
                # We haven't found a leaf yet. Push the children
                # onto the stack
                new_path = path + [node.tag]
                
                for child in children:
                    new_pair = (child, new_path)
                    stack.append(new_pair)
                
            else:
                # we found a leaf node. Turn it into a tuple and 
                # store it in return_me
                try:
                    final_val = node.text.upper()
                except AttributeError:
                    final_val = node.text
                final_list = path + [node.tag, final_val]
                path_tuple = tuple(final_list)
                return_me.add(path_tuple)
            
        return return_me
        
        
    def to_etree(self):
        return self._etree
    
    def __len__(self):
        return len(str(self))
        
    def __str__(self):
        if not self._str_form:
            root = self._etree.getroot()
            self._str_form = ElementTree.tostring(root)
        return self._str_form
        
    def str(self):
        return str(self)
    


    #
    # xml.etree.ElementTree supports some XPath searches. I am sure we will
    # want to extend this as time goes on, but here's one example:
    def matches_xpath_expression(self, xpath_expression):
        nodes = self._etree.findall(xpath_expression)
        return len(nodes) > 0
    
    def matches_query(self, xpath_expression, value):
        """
        Returns True iff there is a path in the XML that matches 
        xpath_expression *and* the last node in the path has a value
        that matches the input value (case insensitive).
        
        Note: this method is slow, and the other, more specialized methods
        of this class should be used instead whenever possible. 
        """
        upper_value = value.upper()
        nodes = self._etree.findall(xpath_expression)
        return any(node.text.upper() == upper_value for node in nodes)
    



    def has_leaf(self, leaf_tag, leaf_value=None):
        """
        Returns True iff the xml has a leaf with the given tag and a text
        attribute of the given value. 
        """
        return (leaf_tag, leaf_value) in self._leaves
    
    def has_path(self, path_tag_list, leaf_value=None):
        """
        Returns True iff the XML has a path matching the tags in the 
        path_tag_list (where the root tag is the first element of the list)
        and the leaf has a text attribute of the given value.
        """
        search_tuple = tuple(path_tag_list + [leaf_value])
        return search_tuple in self._paths
    
    

# We used to use this code for query-aggregation. I strongly suspect that
# we will not need this now that we have has_leaf and has_path, but am leaving
# it in comments for reference and just in case.
#
#    def matches_query(self, xpath_expression, value):
#        #In this case the xpath_expression is case senstive in 
#        #MYSQL but the value it is comparing against is not
#        #Value passed in is expected to be uppercased
#        nodes = self._etree.findall(xpath_expression)
#        return any(node.text.upper() == value for node in nodes)
    
    
    
    


"""
A useful named-tuple for specifying one node in the XML tree. Node-generating
objects will use this to specify generated nodes to the XmlGenerator class.
"""
NodeSpec = collections.namedtuple("NodeSpec", ['is_leaf', 'tag', 'value'])




class BranchGenerator(object):
    """
    Generates a random set of interior XML nodes. Said nodes are returned
    as a list of NodeSpec objects. They will be selected (with replacement)
    from a finite set { "str1", "str2", "str3", ...} according to an 
    arbitrary non-uniform distribution. The string used ("str" in the previous 
    example) must be provided to the constructor, as must be the degree (number 
    of children to generate).
    """ 
    
    def __init__(self, tag_base_string, degree):
        self._tag_base_string = tag_base_string
        self._degree = degree
        
        self._dist = CompactIndependentDistribution()
         
        num_tags = int(1.5 * degree)
        
        for i in xrange(num_tags):
            tag_str = self._tag_base_string + str(i)
            self._dist.add(tag_str, weight_vector(i))
            

    def _generate_node(self):
        tag = self._dist.generate()
        return NodeSpec(is_leaf = False,
                        tag = tag,
                        value = None)
    
    def generate_pdf(self, min, max):
        return self._dist.generate_pdf(min,max)
    
    def generate_nodes(self, path_so_far):
        return [self._generate_node() for _ in xrange(self._degree)]


    def check_forbidden_characters(self, forbidden_chars):
        """
        Raise AssertError if any of the characters in forbidden_characters
        could be in the string form of an XML node generated by this 
        object.
        """
        
        for forbidden_char in forbidden_chars:
            assert forbidden_char not in "<>/"
            assert forbidden_char not in self._tag_base_string
            assert forbidden_char not in "0123456789"
            





class LeafGenerator(object):
    """
    Generates a random set of leaf XML nodes. Said nodes are returned
    as a list of NodeSpec objects. This class must be initialized by a
    DistributionHolder object and a degree (number of nodes to generate).
    The leaf nodes are generated by:
    
    1) Generating a random 'row' from the DistributionHolder, 
    
    2) Selecting (without replacement) a set of row-fields, where the set
       is of size 'degree', and
       
    3) Turning each of these fields (in some random order) into nodes.
    """
    
    def __init__(self, dist_holder, degree):
        
        assert len(dist_holder.var_names) >= degree
        
        self._dist_holder = dist_holder
        self._degree = degree
        
    def _generate_row(self):
        # Note: while this is very much like the code in DataGeneratorEngine,
        # there are some differences. (The code in DataGeneratorEngine, for 
        # example, may not generate every field.) Thus, it doesn't make sense
        # to factor this logic out into DastaGeneratorEngine or 
        # DistributionHolder
        row_dict = {}   
        var_order = self._dist_holder.var_order   
        dist_dict = self._dist_holder.dist_dict
        for var in var_order:
            dist = dist_dict[var]
            v = dist.generate(row_dict)
            row_dict[var] = v
            
        return row_dict
        
         
    def _make_node(self, field, value):
        (tag, _) = spar_vars.sql_info[field]
        converter = spar_vars.VAR_CONVERTERS[field].to_csv
        val_str = converter(value)
        return NodeSpec(is_leaf = True,
                        tag = tag,
                        value = val_str)
        
    def generate_nodes(self, path_so_far):
        row_dict = self._generate_row()
        fields = row_dict.keys()
        selected_fields = spar_random.sample(fields, self._degree)
        selected_values = [row_dict[field] for field in selected_fields]
        
        nodes = [self._make_node(field, value)
                for (field, value) in zip(selected_fields, selected_values)]
        
        return nodes
    
    def generate_pdf(self, field, min, max):
        assert field in self._dist_holder.var_order
        return self._dist_holder.dist_dict[field].generate_pdf(min, max, {})
        
                                                                                  
    def field_size(self):
        return len(self._dist_holder.var_order)   

    def check_forbidden_characters(self, forbidden_chars):
        """
        Raise AssertError if any of the characters in forbidden_characters
        could be in the string form of an XML node generated by this 
        object.
        """
        for forbidden_char in forbidden_chars:
            assert forbidden_char not in "<>/"
        
        for var in self._dist_holder.var_order:
            (tag, _) = spar_vars.sql_info[var]
            for forbidden_char in forbidden_chars:
                assert forbidden_char not in tag
            
            dist = self._dist_holder.dist_dict[var]
            support = dist.support()
            converter = spar_vars.VAR_CONVERTERS[var].to_csv
       
            for val in support:
                val_str = converter(val)
                for forbidden_char in forbidden_chars:
                    assert forbidden_char not in val_str
                
            




class XmlGenerator(object):
    """
    Class to generate random XML trees (in the form of GeneratedXml objects).
    Internally, this class is contains three major components:
    
    * A top-level node (self._top_level_node),
    
    * A list of node-generating objects self._node_generators), with one 
        element for each possible level in the tree, and
        
    * A stack-based function (generate) to iteratively use the 
        node-generators to expand the top-level node into a full tree.
        
    Right now, the list of node-generating objects encodes our current 
    XML-generation template: two levels of interior nodes, each with fan-out 5,
    and each of these 25 paths end with 5 leaf-nodes. Thus, the list of
    node-generating objects will be of length 3: two branch-generators and
    a leaf-generator. Should we decide to change this template, though, this
    list of generators will change.
    """


    
    # Number of children per interior node. Right now, this is constant but
    # may want to allow this to vary depending on the path or level.

    FAN_OUT = 5


    def __init__(self, leaf_distribution_holder):
        
        self._top_level_node = NodeSpec(is_leaf = False, tag = 'xml', 
                                        value = None)

        self._node_generators = [BranchGenerator('a', self.FAN_OUT),
                                 BranchGenerator('b', self.FAN_OUT),
                                 LeafGenerator(leaf_distribution_holder,
                                               self.FAN_OUT)]
        
    def generate(self, *args):
        
        # Note: this used to have a beautiful recursive implementation.
        # It turned out to be a bottleneck, though, so we switched
        # to the monolithic stack-based implementation you see here.
        # If you need to see the recursive implementation for reference, 
        # look in the header for the date of the original version, and then
        # use that to pull this file out of source-control.
        
        root_tag = self._top_level_node.tag
        root_node = ElementTree.Element(root_tag)
        if self._top_level_node.value:
            root_node.text = self._top_level_node.value

        xml_tree = ElementTree.ElementTree(root_node)
        
        if not self._top_level_node.is_leaf:
            
            # Okay, here's the overview of the stack-based algorithm.
            # The stack will be filled with 
            # (Element, path, depth, generator_function) tuples, where
            # the path element is a list of tags leading to (and including)
            # the Element object. While the stack is not empty, we:
            #
            # * Pop the top (Element, path, depth, functiopn) element.
            #
            # * Look at len(path) to figure out which node-generator to call.
            # 
            # * Pass path to the function to get the child nodes.
            # 
            # * For each child node:
            # 
            #    * We add the child nodes to Element.
            # 
            #    * IF the child is not a leaf, we push it (and its path,
            #      depth, and new function) onto the stack.
            #
            # Note: while the depth element and function re redundant, this
            # method is a bottleneck and it seems to speed things up.
        
        
            generators = [generator.generate_nodes
                          for generator in self._node_generators] + [None]
            stack = []
            first_stack_element = (root_node, [root_tag], 0, generators[0])        
            stack.append(first_stack_element)
            Element = ElementTree.Element
            stack_pop = stack.pop
            stack_append = stack.append

            while stack:
                
                (curr_element, curr_path, curr_depth, curr_generator) = stack_pop()
                child_node_specs = curr_generator(curr_path)
                
                new_depth = curr_depth + 1
                new_generator = generators[new_depth]
                
                for child_spec in child_node_specs:
                    
                    new_tag = child_spec.tag
                    new_path = curr_path + [new_tag]
                    new_node = Element(new_tag)
                    if child_spec.value: new_node.text = child_spec.value
                    curr_element.append(new_node)
                        
                    if not child_spec.is_leaf:
                        
                        new_stack_element = (new_node, new_path, new_depth, new_generator)
                        stack_append(new_stack_element)

        return GeneratedXml(xml_tree)

    def generate_node_pdf(self, level, min, max):
        assert level < len(self._node_generators)-1
        return self._node_generators[level].generate_pdf(min, max)
    
    def generate_leaf_pdf(self, field, min, max):
        return self._node_generators[-1].generate_pdf(field, min, max)
    
    def leaf_field_size(self):
        return self._node_generators[-1].field_size()

    def check_forbidden_characters(self, forbidden_chars):
        """
        Raise AssertError if any of the characters in forbidden_characters
        could be in the string form of an XML tree generated by this 
        object.
        """
        
        for forbidden_char in forbidden_chars:
            assert forbidden_char not in "<>/xml"
            
        for node_generator in self._node_generators:
            node_generator.check_forbidden_characters(forbidden_chars)
